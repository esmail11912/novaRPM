<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>RPM 3-SAT Solver</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f9f9f9; }
    textarea { width: 100%; height: 150px; margin-top: 10px; }
    button { margin-top: 15px; padding: 10px 15px; font-size: 16px; }
    .output { margin-top: 20px; background: #fff; padding: 15px; border-radius: 8px; border: 1px solid #ddd; }
    .clause-box { padding: 8px; margin: 5px 0; border-radius: 6px; font-family: monospace; }
  </style>
</head>
<body>

  <h2>🚀 RPM 3-SAT Solver – Reflective Pressure Model</h2>
  <p>Enter 3-SAT clauses (text or numeric form). One clause per line:</p>
  <ul>
    <li>(a ∨ ¬b ∨ c)</li>
    <li>(-1 ∨ 2 ∨ -3)</li>
  </ul>

  <textarea id="clauseInput" placeholder="Enter clauses here..."></textarea>
  <br>
  <button onclick="processClauses()">➕ Process Clauses</button>
  <button onclick="calculateInitialPressure()">💡 Initial Pressures</button>
  <button onclick="runRPMIteration()">⚙️ Run RPM Solver</button>

  <div class="output" id="resultArea"></div>

  <div id="visualOutput" style="margin-top: 30px;">
    <h3>🎯 Clause Status:</h3>
    <div id="clauseStatusArea"></div>
  </div>

<script>
  const varMap = {};
  let varCounter = 1;
  let allClauses = [];
  let pressures = {};

  function convertLiteral(lit) {
    lit = lit.trim();
    if (/^-?\\d+$/.test(lit)) return parseInt(lit);
    let neg = lit.includes('¬') || lit.includes('~') || lit.startsWith('-');
    let name = lit.replace(/[()¬~\\s-]/g, '');
    if (!varMap[name]) varMap[name] = varCounter++;
    return neg ? -varMap[name] : varMap[name];
  }

  function processClauses() {
    const raw = document.getElementById('clauseInput').value;
    const lines = raw.split('\\n');
    const parsed = [];

    for (let line of lines) {
      if (!line.trim()) continue;
      let clean = line.replace(/[()]/g, '').replace(/∨/g, '|');
      let parts = clean.split('|').map(s => s.trim());
      if (parts.length !== 3) continue;
      const clause = parts.map(convertLiteral);
      parsed.push(clause);
    }

    allClauses = parsed;

    let resultText = "<b>📋 Parsed Clauses:</b><br><pre>" + JSON.stringify(parsed, null, 2) + "</pre>";
    resultText += "<b>🔑 Variable Mapping:</b><br><pre>" + JSON.stringify(varMap, null, 2) + "</pre>";

    document.getElementById('resultArea').innerHTML = resultText;
  }

  function calculateInitialPressure() {
    const counts = {};
    for (let clause of allClauses) {
      for (let lit of clause) {
        let key = Math.abs(lit);
        if (!counts[key]) counts[key] = { pos: 0, neg: 0 };
        if (lit > 0) counts[key].pos++;
        else counts[key].neg++;
      }
    }

    pressures = {};
    for (let key in counts) {
      let c = counts[key];
      pressures[key] = c.pos - c.neg;
    }

    let result = "<b>🧠 Initial Pressure for Variables:</b><br><pre>" + JSON.stringify(pressures, null, 2) + "</pre>";
    result += "<b>📊 Positive/Negative Count:</b><br><pre>" + JSON.stringify(counts, null, 2) + "</pre>";
    document.getElementById('resultArea').innerHTML += result;
  }

  function runRPMIteration() {
    const variableValues = {};
    const netPressure = {};

    for (let key in pressures) {
      let val = pressures[key];
      variableValues[key] = val > 0 ? 1 : 0;
      netPressure[key] = 0;
    }

    let steps = 0;
    let maxSteps = 20;

    while (steps++ < maxSteps) {
      let clauseChanged = false;
      for (let key in netPressure) netPressure[key] = 0;

      for (let clause of allClauses) {
        let satisfied = false;
        for (let lit of clause) {
          let varId = Math.abs(lit);
          let val = variableValues[varId];
          let isPositive = lit > 0;
          if ((isPositive && val === 1) || (!isPositive && val === 0)) {
            satisfied = true;
            break;
          }
        }

        if (!satisfied) {
          clauseChanged = true;
          for (let lit of clause) {
            let varId = Math.abs(lit);
            netPressure[varId] += (lit > 0) ? -1 : 1;
          }
        }
      }

      for (let key in variableValues) {
        if (netPressure[key] > 0) variableValues[key] = 1;
        else if (netPressure[key] < 0) variableValues[key] = 0;
      }

      if (!clauseChanged) break;
    }

    renderClauseStatus(variableValues);

    let finalResult = "<b>🔄 Final Values After RPM:</b><br><pre>" + JSON.stringify(variableValues, null, 2) + "</pre>";
    finalResult += "<b>✅ Result:</b> " + (steps < maxSteps ? "SATISFIABLE ✔️" : "UNSATISFIABLE ❌ (unstable)");
    document.getElementById('resultArea').innerHTML += "<br>" + finalResult;
  }

  function renderClauseStatus(variableValues) {
    let html = "";
    for (let i = 0; i < allClauses.length; i++) {
      const clause = allClauses[i];
      let satisfied = false;

      for (let lit of clause) {
        let varId = Math.abs(lit);
        let val = variableValues[varId];
        let isPositive = lit > 0;
        if ((isPositive && val === 1) || (!isPositive && val === 0)) {
          satisfied = true;
          break;
        }
      }

      let color = satisfied ? "#c8f7c5" : "#f7c5c5";
      let emoji = satisfied ? "✅" : "❌";
      html += `<div class="clause-box" style="background:${color}"><b>C${i+1}</b>: [ ${clause.join(", ")} ] ${emoji}</div>`;
    }

    document.getElementById('clauseStatusArea').innerHTML = html;
  }
</script>

</body>
</html>
