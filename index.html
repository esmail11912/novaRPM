<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<title>RPM 3-SAT Solver</title>
<style>
    body { font-family: sans-serif; padding: 20px; background: #f9f9f9; }
    textarea { width: 100%; height: 150px; margin-top: 10px; }
    button { margin-top: 15px; padding: 10px 15px; font-size: 16px; }
    .output { margin-top: 20px; background: #fff; padding: 15px; border-radius: 8px; border: 1px solid #ddd; }
    .clause-box { padding: 8px; margin: 5px 0; border-radius: 6px; font-family: monospace; }
  </style>
</head>
<body>
<h2>ğŸš€ RPM 3-SAT Solver â€“ Reflective Pressure Model</h2>
<p>Enter 3-SAT clauses (text or numeric form). One clause per line:</p>
<ul>
<li>(a âˆ¨ Â¬b âˆ¨ c)</li>
<li>1 2 3</li>
<li>(-1 âˆ¨ 2 âˆ¨ -3)</li>
</ul>
<textarea id="clauseInput" placeholder="Enter clauses here..."></textarea>
<br/>
<button onclick="processClauses()">â• Process Clauses</button>
<button onclick="calculateInitialPressure()">ğŸ’¡ Initial Pressures</button>
<button onclick="runRPMIteration()">âš™ï¸ Run RPM Solver</button>
<div class="output" id="resultArea"></div>
<div id="visualOutput" style="margin-top: 30px;">
<h3>ğŸ¯ Clause Status:</h3>
<div id="clauseStatusArea"></div>
</div>
<div id="pressureBars" style="margin-top: 30px;">
<h3>ğŸ“Š Variable Pressures:</h3>
<div id="barChartArea"></div>
</div>
<script>
  const varMap = {};
  let varCounter = 1;
  let allClauses = [];
  let pressures = {};

  function convertLiteral(lit) {
    lit = lit.trim();
    if (/^-?\d+$/.test(lit)) return parseInt(lit);
    let neg = lit.includes('Â¬') || lit.includes('~') || lit.startsWith('-');
    let name = lit.replace(/[()Â¬~\s-]/g, '');
    if (!varMap[name]) varMap[name] = varCounter++;
    return neg ? -varMap[name] : varMap[name];
  }

  function processClauses() {
    let i = 0;
    let warnings = [];
    const raw = document.getElementById('clauseInput').value;
    const lines = raw.split('\n');
    const parsed = [];

    for (let line of lines) {
      i++;
      if (!line.trim()) continue;
      let clean = line.replace(/[()]/g, '').replace(/âˆ¨/g, '|');

      let parts;
      if (clean.includes('|')) {
        parts = clean.split('|').map(s => s.trim());
      } else {
        parts = clean.trim().split(/\s+/);
      }

      if (parts.length !== 3) {
        warnings.push(`âš ï¸ Clause ${i} ignored: must contain exactly 3 literals â†’ "${line.trim()}"`);
        continue;
      }
      const clause = parts.map(convertLiteral);
      parsed.push(clause);
    }

    allClauses = parsed;

    
        let resultText = "<b>ğŸ“‹ Parsed Clauses:</b><br>";
        resultText += "<table border='1' cellpadding='5' cellspacing='0' style='border-collapse:collapse;width:80%;margin:10px auto;text-align:center'>";
        resultText += "<tr style='background-color:#f2f2f2'><th>#</th><th>Clause (Raw)</th><th>Visual</th></tr>";
        for (let i = 0; i < parsed.length; i++) {
            let raw = parsed[i];
            let visual = raw.map(v => v > 0 ? "x" + v : "Â¬x" + Math.abs(v)).join(" âˆ¨ ");
            let color = i % 2 === 0 ? "#ffffff" : "#f9f9f9";
            resultText += `<tr style="background-color:${color}"><td>${i + 1}</td><td>${JSON.stringify(raw)}</td><td>${visual} ğŸ§©</td></tr>`;
        }
        resultText += "</table>";
        
    resultText += "<b>ğŸ”‘ Variable Mapping:</b><br><pre>" + JSON.stringify(varMap, null, 2) + "</pre>";

    if (warnings.length > 0) {
      resultText += "<b>âš ï¸ Ignored Clauses:</b><ul>";
      for (let w of warnings) {
        resultText += `<li style='color:#b30000;'>${w}</li>`;
      }
      resultText += "</ul>";
    }
    document.getElementById('resultArea').innerHTML = resultText;
  }

  function calculateInitialPressure() {
    const counts = {};
    for (let clause of allClauses) {
      for (let lit of clause) {
        let key = Math.abs(lit);
        if (!counts[key]) counts[key] = { pos: 0, neg: 0 };
        if (lit > 0) counts[key].pos++;
        else counts[key].neg++;
      }
    }

    pressures = {};
    for (let key in counts) {
      let c = counts[key];
      pressures[key] = c.pos - c.neg;
    }

    
    let table = "<b>ğŸ§  Initial Pressure for Variables:</b><br>";
    table += "<table border='1' cellpadding='6' cellspacing='0' style='border-collapse:collapse;width:80%;margin:10px auto;text-align:center'>";
    table += "<tr style='background-color:#e2e2e2'><th>Variable</th><th>Positive</th><th>Negative</th><th>Net Pressure</th></tr>";
    for (let key in counts) {
      const pos = counts[key].pos;
      const neg = counts[key].neg;
      const net = pos - neg;
      const color = net > 0 ? "#d4f4d2" : net < 0 ? "#f8d4d4" : "#f0f0f0";
      const emoji = net > 0 ? "ğŸŸ¢" : net < 0 ? "ğŸ”´" : "âšª";
      table += `<tr style="background-color:${color}"><td>x${key}</td><td>${pos}</td><td>${neg}</td><td><b>${net}</b> ${emoji}</td></tr>`;
    }
    table += "</table>";
    document.getElementById('resultArea').innerHTML += table;
    
    
    document.getElementById('resultArea').innerHTML += result;

    renderPressureBars(); // Ù†Ù…Ø§ÛŒØ´ Ù†ÙˆØ§Ø± ÙØ´Ø§Ø±
  }

  function runRPMIteration() {
  const variableValues = {};
  const netPressure = {};
  const traceLog = [];

  for (let key in pressures) {
    variableValues[key] = pressures[key] > 0 ? 1 : 0;
    netPressure[key] = 0;
  }

  let steps = 0;
  let maxSteps = 20;
  let traceHTML = "<h3>ğŸ§­ RPM Execution Trace</h3><table border='1' style='border-collapse:collapse;width:90%;margin:auto;text-align:center'><tr><th>Step</th><th>Updates</th><th>Net Pressure</th><th>SAT</th><th>UNSAT</th></tr>";

  while (steps++ < maxSteps) {
    let clauseChanged = false;
    for (let key in netPressure) netPressure[key] = 0;

    let sat = 0;
    let unsat = 0;

    for (let clause of allClauses) {
      let satisfied = false;
      for (let lit of clause) {
        const id = Math.abs(lit);
        const val = variableValues[id];
        const positive = lit > 0;
        if ((positive && val === 1) || (!positive && val === 0)) {
          satisfied = true;
          break;
        }
      }
      if (!satisfied) {
        unsat++;
        clauseChanged = true;
        for (let lit of clause) {
          const id = Math.abs(lit);
          netPressure[id] += (lit > 0) ? -1 : 1;
        }
      } else {
        sat++;
      }
    }

    const updates = [];
    for (let key in variableValues) {
      const oldVal = variableValues[key];
      if (netPressure[key] > 0) variableValues[key] = 1;
      else if (netPressure[key] < 0) variableValues[key] = 0;
      if (variableValues[key] !== oldVal) {
        updates.push(`x${key} â†’ ${variableValues[key]}`);
      }
    }

    traceLog.push({
      step: steps,
      updates: updates,
      net: { ...netPressure },
      sat,
      unsat
    });

    traceHTML += `<tr><td>${steps}</td><td>${updates.join(", ") || "-"}</td><td>${JSON.stringify(netPressure)}</td><td>${sat}</td><td>${unsat}</td></tr>`;

    if (!clauseChanged) break;
  }

  traceHTML += "</table><p style='text-align:center'><b>âœ… Final Result:</b> " + (steps < maxSteps ? "SATISFIABLE âœ”ï¸" : "UNSATISFIABLE âŒ") + "</p>";
  document.getElementById("traceSection").innerHTML = traceHTML;

  renderClauseStatus(variableValues);
    renderLogicalExplanations(variableValues);

  let finalResultTable = "<b>ğŸ”„ Final Values After RPM:</b><br>";
  finalResultTable += "<table border='1' cellpadding='6' cellspacing='0' style='border-collapse:collapse;width:60%;margin:10px auto;text-align:center'>";
  finalResultTable += "<tr style='background-color:#e2e2e2'><th>Variable</th><th>Assigned Value</th><th>Status</th></tr>";
  for (let key in variableValues) {
    const val = variableValues[key];
    const emoji = val === 1 ? "âœ…" : "âŒ";
    const color = val === 1 ? "#d0f0d0" : "#f8d0d0";
    finalResultTable += `<tr style="background:${color}"><td>x${key}</td><td>${val}</td><td>${emoji}</td></tr>`;
  }
  finalResultTable += "</table>";
  finalResultTable += "<b>âœ… Result:</b> " + (steps < maxSteps ? "SATISFIABLE âœ”ï¸" : "UNSATISFIABLE âŒ (unstable)");
  document.getElementById("resultArea").innerHTML += "<br>" + finalResultTable;
}

  function renderClauseStatus(variableValues) {
    let html = "";
    for (let i = 0; i < allClauses.length; i++) {
      const clause = allClauses[i];
      let satisfied = false;

      for (let lit of clause) {
        let varId = Math.abs(lit);
        let val = variableValues[varId];
        let isPositive = lit > 0;
        if ((isPositive && val === 1) || (!isPositive && val === 0)) {
          satisfied = true;
          break;
        }
      }

      let color = satisfied ? "#c8f7c5" : "#f7c5c5";
      let emoji = satisfied ? "âœ…" : "âŒ";
      html += `<div class="clause-box" style="background:${color}"><b>C${i+1}</b>: [ ${clause.join(", ")} ] ${emoji}</div>`;
    }

    document.getElementById('clauseStatusArea').innerHTML = html;
  }

  function renderPressureBars() {
    let html = "";

    for (let key in pressures) {
      const p = pressures[key];
      const width = Math.min(Math.abs(p) * 30, 200);
      const color = p > 0 ? "#88e188" : p < 0 ? "#f88" : "#ccc";
      const label = p > 0 ? `+${p}` : `${p}`;

      html += `
        <div style="margin-bottom: 8px;">
          <b>x${key}</b>
          <div style="display: inline-block; width: ${width}px; background: ${color}; height: 20px; margin-left: 10px; border-radius: 4px;"></div>
          <span style="margin-left: 10px;">${label}</span>
        </div>
      `;
    }

    document.getElementById('barChartArea').innerHTML = html;
  }
</script>

<div id="traceSection" style="margin-top: 40px;"></div>

<!-- Real-Time RPM Execution Trace (Enhanced) -->
<div id="traceSection" style="margin-top: 40px;">
  <h2 style="text-align:center;">ğŸ§­ RPM Execution Trace (Enhanced)</h2>
  <div id="rpmTraceTable" style="margin-top: 20px;"></div>
</div>

<script>
let rpmTrace = [];

function runRPMIteration() {
  const variableValues = {};
  const netPressure = {};
  rpmTrace = [];

  for (let key in pressures) {
    let val = pressures[key];
    variableValues[key] = val > 0 ? 1 : 0;
    netPressure[key] = 0;
  }

  let steps = 0;
  let maxSteps = 20;

  while (steps++ < maxSteps) {
    let clauseChanged = false;
    for (let key in netPressure) netPressure[key] = 0;

    let unsatisfiedClauses = [];

    for (let i = 0; i < allClauses.length; i++) {
      let clause = allClauses[i];
      let satisfied = false;

      for (let lit of clause) {
        let varId = Math.abs(lit);
        let val = variableValues[varId];
        let isPositive = lit > 0;
        if ((isPositive && val === 1) || (!isPositive && val === 0)) {
          satisfied = true;
          break;
        }
      }

      if (!satisfied) {
        clauseChanged = true;
        unsatisfiedClauses.push("C" + (i + 1));
        for (let lit of clause) {
          let varId = Math.abs(lit);
          netPressure[varId] += (lit > 0) ? -1 : 1;
        }
      }
    }

    let updates = [];
    for (let key in variableValues) {
      const oldVal = variableValues[key];
      if (netPressure[key] > 0) variableValues[key] = 1;
      else if (netPressure[key] < 0) variableValues[key] = 0;
      if (variableValues[key] !== oldVal)
        updates.push("x" + key + " â†’ " + variableValues[key]);
    }

    let snapshot = Object.keys(variableValues).sort((a,b)=>a-b).map(k => "x" + k + "=" + variableValues[k]).join(", ");
    let netP = Object.keys(netPressure).sort((a,b)=>a-b).map(k => "x" + k + ":" + netPressure[k]).join(", ");
    let unsatStr = unsatisfiedClauses.join(", ") || "â€“";

    rpmTrace.push({
      step: steps,
      updates: updates.join(", "),
      netPressure: netP,
      snapshot: snapshot,
      unsatisfied: unsatStr
    });

    if (!clauseChanged) break;
  }

  renderClauseStatus(variableValues);
    renderLogicalExplanations(variableValues);
  renderPressureBars();
  renderFinalTrace();
}

function renderFinalTrace() {
  if (!rpmTrace.length) return;

  let html = `
  <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;width:95%;margin:auto;text-align:center">
    <tr style="background:#333;color:#fff">
      <th>Step</th>
      <th>Updates</th>
      <th>Net Pressure</th>
      <th>Assignment Snapshot</th>
      <th>Unsatisfied Clauses</th>
    </tr>`;

  for (let row of rpmTrace) {
    html += `<tr>
      <td>${row.step}</td>
      <td>${row.updates || "â€“"}</td>
      <td style="font-family:monospace">${row.netPressure}</td>
      <td style="font-family:monospace">${row.snapshot}</td>
      <td style="color:${row.unsatisfied === "â€“" ? 'green' : 'red'}">${row.unsatisfied}</td>
    </tr>`;
  }

  html += "</table>";

  html += `<div style="margin-top:20px;padding:15px;background:#fff4f4;border:1px solid #ffcccc;border-radius:10px;">
    <b>ğŸ”¬ Analytical Conclusion:</b><br>
    After ${rpmTrace.length} iteration(s), the RPM model ${rpmTrace[rpmTrace.length - 1].unsatisfied === "â€“" ? 'satisfied all clauses âœ”ï¸' : 'could not satisfy all clauses âŒ'}.<br>
    ${rpmTrace[rpmTrace.length - 1].unsatisfied !== "â€“" ? 'Unresolved clause(s): ' + rpmTrace[rpmTrace.length - 1].unsatisfied : ''}
  </div>`;

  document.getElementById("rpmTraceTable").innerHTML = html;
}
</script>

</body>

<!-- Author Info -->
<div style="margin-top:40px; padding:20px; background:#f9f9f9; border:1px solid #ccc; border-radius:10px; font-family:sans-serif;">
  <h3>ğŸ”¬ Developed by</h3>
  <p><strong>Esmail Mohammadzadeh Sharif</strong><br/>
  Independent Researcher<br/>
  ğŸ“§ esmail.mohammadzadeh.sh@gmail.com<br/>
  ğŸŒ This solver is open for review, discussion, and scientific exploration.
  </p>
</div>

</html>
<!-- SAT Clause Analytical Breakdown -->

<!-- ğŸ§  Clause Analysis â€“ Logical Explanations -->
<div class="output" style="margin-top: 40px;">
  <h3>ğŸ§  Clause Analysis â€“ Logical Explanations</h3>
  <div id="clauseLogicArea" style="background:#fefce8; padding:15px; border-radius:10px; border:1px solid #f3e29f; font-family:monospace;"></div>
</div>
<script>
  function renderLogicalExplanations(variableValues) {
    let logicHtml = "";
    for (let i = 0; i < allClauses.length; i++) {
      const clause = allClauses[i];
      let clauseLogic = "";
      let satisfied = false;
      let clauseExplained = clause.map(lit => {
        const varId = Math.abs(lit);
        const val = variableValues[varId];
        const isPositive = lit > 0;
        const result = (isPositive && val === 1) || (!isPositive && val === 0);
        satisfied = satisfied || result;
        return (isPositive ? "x" : "Â¬x") + varId + "=" + val + (result ? "âœ”ï¸" : "âŒ");
      }).join(" âˆ¨ ");
      clauseLogic += `<p><b>Clause C${i + 1}:</b> ${clauseExplained}<br>`;
      clauseLogic += satisfied ? "âœ… <b>Satisfied</b></p>" : "âŒ <b>Unsatisfied</b></p>";
      logicHtml += clauseLogic;
    }
    document.getElementById("clauseLogicArea").innerHTML = logicHtml;
  }
</script>


<div class="output" style="margin-top: 40px;">
  <h3>ğŸ“˜ Clause-by-Clause Analytical Proof</h3>
  <div style="background:#f0f9ff; padding:15px; border-radius:10px; border:1px solid #b3d8ff;">
    <p><b>Clause C1: [1, -2, 3]</b><br>
    Mapped Clause: <code>x1 âˆ¨ Â¬x2 âˆ¨ x3</code><br>
    Assigned Values: x1=1 (âœ”ï¸), x2=1 (Â¬x2 âŒ), x3=1 (âœ”ï¸)<br>
    Evaluation: <code>âœ”ï¸ âˆ¨ âŒ âˆ¨ âœ”ï¸ = âœ”ï¸</code><br>
    âœ… <b>SATISFIED</b></p>

    <p><b>Clause C2: [1, 2, 3]</b><br>
    Mapped Clause: <code>x1 âˆ¨ x2 âˆ¨ x3</code><br>
    Assigned Values: x1=1 (âœ”ï¸), x2=1 (âœ”ï¸), x3=1 (âœ”ï¸)<br>
    Evaluation: <code>âœ”ï¸ âˆ¨ âœ”ï¸ âˆ¨ âœ”ï¸ = âœ”ï¸</code><br>
    âœ… <b>SATISFIED</b></p>

    <p><b>Clause C3: [-1, 2, -3]</b><br>
    Mapped Clause: <code>Â¬x1 âˆ¨ x2 âˆ¨ Â¬x3</code><br>
    Assigned Values: x1=1 (Â¬x1 âŒ), x2=1 (âœ”ï¸), x3=1 (Â¬x3 âŒ)<br>
    Evaluation: <code>âŒ âˆ¨ âœ”ï¸ âˆ¨ âŒ = âœ”ï¸</code><br>
    âœ… <b>SATISFIED</b></p>
  </div>
</div>

